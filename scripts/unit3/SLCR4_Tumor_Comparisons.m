%[text] # Tumor Comparison
%[text] In this module, we examine the tumors that we segmented in Slicer. Specifically, we are going to load the Merged segmentation file that contains the three segments. Since all three segmentations overlap, Slcer saved these segmentations into different layers. So, here we are going to show you how to handle segmentations in different layers
clearvars
close all hidden
setupMatGeom
%%
%[text] ## Load Merged tumor segmentation
%[text] #### Set Path
paths.project = "/Users/ernesto/MATLAB-Drive/MtMdata/unit3/Tumors"; % in unit3 folder %[control:filebrowser:80e3]{"position":[17,67]}
ls(paths.project) % display folder contents
paths.intensity = fullfile(paths.project,"MRBT1stripped.nrrd");
paths.segment = fullfile(paths.project,"Merged Segmentations.seg.nrrd")
table(fieldnames(paths),structfun(@(x) exist(x,"file"),paths),VariableNames=["path" "X"]) % make sure paths exist 
%[text] 
%%
%[text] ### Load medical volumes
intMV = medicalVolume(paths.intensity)
segMV = medicalVolume(paths.segment)
%[text] - Notice the voxels in the segmentation array are 4D - this means the segmentations were stored in different layers
%[text] - So, you have to be careful how you process this data. \
%%
%[text] ### Get segmentation table
%[text] The segmentation table lists both the layer and the label value
segT = mmGetSlicerSegTable(paths.segment)
%[text] - Notice we have three layers, and in every layer, the segmentation has a label of 1
%[text] - Since we have 3 different layers, we can't just plug-in segmentation volume into volshow.
%[text] - We need to index out each segmentation \
%%
%[text] ### Extract Segmentations from medical volume
%[text] Luckily, the course function **`mmGetMedicalVolumeSegment`** can handle layers. 
brainSeg = mmGetMedicalVolumeSegment(segMV,segT,segName="brain")
t1Seg = mmGetMedicalVolumeSegment(segMV,segT,segName="Tumor1")
t2Seg = mmGetMedicalVolumeSegment(segMV,segT,segName="Tumor2")
%[text] - now we have 3 structures that contain the three different masks \
%%
%[text] ### Display our segmentations
%[text] Here we overlay one of the tumor segmentations on the intensity volume. volshow can handle mVint, since it is not a 4D array. We then just plug in the tumor1 mask as the Overlay data
hvr3 = viewer3d(BackgroundColor="white",BackgroundGradient="off",CameraZoom=1); % set background color to white and turn off gradient
hvol = volshow(intMV,Parent=hvr3, ...
    RenderingStyle="GradientOpacity", ... % makes intensity volume transparent
    OverlayData=t1Seg.mask);
%[text] - the default display settings aren't especially exciting \
%%
hvol.Alphamap = single(linspace(0,0.75,256)); % voxel alpha values
%%
hvol.OverlayAlpha = single(0.75); % increase alpha of overlay
%%
hvol.RenderingStyle="CinematicRendering";
%%
%[text] ## Display Surfaces
%[text] To display surfaces, we use the function **`mmPlotMask2Surface`** and we input the mask from the Seg Structures (generated by **`mmGetMedicalVolumeSegment`**). To properly display our structures in mm space, we assign the transformation matrix to `tform`, using the function **`intrinsicToWorldMapping`**. We will add this variable to our plot call. Since we have multiple seg structures, we need to call **`mmPlotMask2Surface`** multiple times, but each call to **`mmPlotMask2Surface`** adds lighting to the scene. Too much lighting, will make the scene look washed out. So, on the first call to **`mmPlotMask2Surface,`** we set the option 'lightEMup' to false. This adds no lighting to the scene. On the second call, we set the option to true (this is the default). And we get reasonable lighting on the scene.  
%[text] 
%%
[0.969 0.961 0.816] % choose a suitable color for the brain segmentation %[control:colorPicker:2342]{"position":[1,20]}
%%
tform = intrinsicToWorldMapping(segMV.VolumeGeometry); % create transformation matrix (scale, rotate, translate)
figure
mmPlotMask2Surface(brainSeg.mask,"fcolor",'#f7f5d0','affTrfm',tform.A,'smooth',true,'lightEMup',false);
mmPlotMask2Surface(t1Seg.mask,"fcolor",'cyan','affTrfm',tform.A,'smooth',false, 'lightEMup',true);
%%
figure; 
t1Seg.hp = mmPlotMask2Surface(t1Seg.mask,"fcolor",'cyan','affTrfm',tform.A,'smooth',false, 'lightEMup',false);
t2Seg.hp = mmPlotMask2Surface(t2Seg.mask,"fcolor",'green','affTrfm',tform.A,'smooth',false, 'lightEMup',true);
%%
%[text] ### Calculate extent of tumors
%[text] Since we transformed the tumors, the measurements are in mm and match pretty close to what we measured in Slicer
range(t1Seg.hp.Vertices);
range(t2Seg.hp.Vertices);
%[text] ### 
%%
%[text] ## Segmentation Analysis
%[text] We can compare the tumor segmentations use a dice analysis
dice(t1Seg.mask,t2Seg.mask)
%[text] - pretty high match \
%%
rp = table;
rp = table("Tumor1", t1Seg.volume*prod(t1Seg.spacing), ...
    mean(intMV.Voxels(t1Seg.mask)), ...
    range(t1Seg.hp.Vertices), ...
    VariableNames=["Segment", "Volume","HU","Extent"])
rp = [rp;...
    table("Tumor2", ...
    t2Seg.volume*prod(t1Seg.spacing), ...
    mean(intMV.Voxels(t2Seg.mask)), ...
    range(t2Seg.hp.Vertices), ...
    VariableNames=["Segment", "Volume","HU","Extent"])]
%%
%[text] 

%[appendix]{"version":"1.0"}
%---
%[metadata:view]
%   data: {"layout":"inline"}
%---
%[control:filebrowser:80e3]
%   data: {"browserType":"Folder","defaultValue":"\"\"","label":"select Tumor folder","run":"Section"}
%---
%[control:colorPicker:2342]
%   data: {"colorFormat":"RGB [0-1]","defaultValue":"[1 1 1]","label":"Color picker","run":"Section"}
%---
